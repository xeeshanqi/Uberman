<html>
<body>
<script type='text/javascript'>

function PathfindingTest()
{
	this.main = function()
	{
		var map0 = new Map
		(
			"Map 0",
			new Coords(16, 16),
			new Array
			(
				"................",
				"................",
				"...~~~..........",
				".....~..........",
				".....~..........",
				".....~~~~~......",
				".........~~~....",
				"...........~....",
				".........~~~....",
				".....~~~~~......",
				".....~..........",
				".....~..........",
				".....~..........",
				".....~..........",
				".....~..........",
				".....~.........."
			)
		);

		document.body.appendChild
		(
			map0.convertToHTMLElement()
		);

		var path0 = new Path
		(
			map0,
			new Coords(4, 5),
			new Coords(9, 12)
		);

		document.body.appendChild
		(
			path0.convertToHTMLElement()
		);

	}
}

function Coords(x, y)
{
	this.x = x;
	this.y = y;
}
{
	var prototype = Coords.prototype;

	prototype.absolute = function()
	{
		this.x = Math.abs(this.x);
		this.y = Math.abs(this.y);

		return this;
	}

	prototype.clone = function()
	{
		return new Coords(this.x, this.y);
	}

	prototype.equals = function(other)
	{
		return (this.x == other.x && this.y == other.y);
	}

	prototype.overwriteWith = function(other)
	{
		this.x = other.x;
		this.y = other.y;

		return this;
	}

	prototype.subtract = function(other)
	{
		this.x -= other.x;
		this.y -= other.y;

		return this;
	}

	prototype.sumOfXAndY = function()
	{
		return this.x + this.y;
	}

	prototype.toString = function()
	{
		return "(" + this.x + "," + this.y + ")";
	}
}

function Map(name, cellSizeInPixels, cellsAsStrings)
{
	this.cellsAsStrings = cellsAsStrings;	
	this.cellSizeInPixels = cellSizeInPixels;
	this.sizeInCells = new Coords
	(
		this.cellsAsStrings[0].length, 
		this.cellsAsStrings.length
	);

}
{
	var prototype = Map.prototype;

	prototype.cellAtPos = function(cellPos)
	{
		var codeChar = this.cellsAsStrings[cellPos.y][cellPos.x];

		return new MapCell
		(
			TerrainInstances._Lookup[codeChar]
		);
	}

	prototype.convertToHTMLElement = function()
	{
		var returnValue = document.createElement("table");
		returnValue.style.backgroundColor = "#888888";
		returnValue.cellPadding = 0;
		returnValue.border = 0;
		returnValue.cellSpacing = 0;

		for (var y = 0; y < this.cellsAsStrings.length; y++)
		{
			var trForRow = document.createElement("tr");

			var cellRowAsString = this.cellsAsStrings[y];

			for (var x = 0; x < cellRowAsString.length; x++)
			{
				var cellAsChar = cellRowAsString[x];

				tdForCell = document.createElement("td");

				tdForCell.style.backgroundColor = TerrainInstances._Lookup[cellAsChar].color;
				tdForCell.style.width = this.cellSizeInPixels.x;
				tdForCell.style.height = this.cellSizeInPixels.y; 

				trForRow.appendChild(tdForCell);
			}

			returnValue.appendChild(trForRow);
		}

		return returnValue;
	}
}

function MapCell(terrain)
{
	this.terrain = terrain;
}

function Path(map, startPos, goalPos)
{
	this.map = map;
	this.startPos = startPos;
	this.goalPos = goalPos;

	var openList = new Array();
	var openLookup = new Array();
	var closedLookup = new Array();

	var startNode = new PathNode
	(
		startPos,
		0,
		goalPos.clone().subtract(startPos).absolute().sumOfXAndY(),
		null
	);

	openList.push(startNode);

	while (openList.length > 0)
	{
		var current = openList[0];

		if (current.cellPos.equals(goalPos) == true)
		{	
			this.nodes = new Array();

			while (current != null)
			{
				this.nodes.splice(0, 0, current);
				current = current.prev;
			}
			break;
		}

		openList.splice(0, 1);
		var currentIndex = "" + (current.cellPos.y * map.sizeInCells.y + current.cellPos.x);
		closedLookup[currentIndex] = current;

		var neighbors = this.getNeighborsForNode(map, current, goalPos);

		for (var n = 0; n < neighbors.length; n++)
		{
			var neighbor = neighbors[n];
			var neighborPos = neighbor.cellPos;

			var neighborIndex = "" + (neighborPos.y * map.sizeInCells.y + neighborPos.x);

			if (closedLookup[neighborIndex] == null && openLookup[neighborIndex] == null)
			{
				var i;
				for (i = 0; i < openList.length; i++)
				{
					var nodeFromOpenList = openList[i];
					if (neighbor.costToGoalEstimated < nodeFromOpenList.costToGoalEstimated)
					{
						break;
					}
				}

				openList.splice(i, 0, neighbor);
				openLookup[neighborIndex] = neighbor;
			}
		}
	}	
}
{
	var prototype = Path.prototype;

	prototype.convertToHTMLElement = function()
	{
		var returnValue = document.createElement("div");
		returnValue.cellPadding = 0;
		returnValue.border = 0;
		returnValue.cellSpacing = 0;

		var cellSizeInPixels = this.map.cellSizeInPixels;

		for (var i = 0; i < this.nodes.length; i++)
		{
			var node = this.nodes[i];
			var nodeCellPos = node.cellPos;

			var divForNode = document.createElement("div");
			divForNode.style.position = "absolute";
			divForNode.style.width = cellSizeInPixels.x + "px";
			divForNode.style.height = cellSizeInPixels.y + "px";
			divForNode.style.left = (nodeCellPos.x * cellSizeInPixels.x + cellSizeInPixels.x / 2) + "px";
			divForNode.style.top = (nodeCellPos.y * cellSizeInPixels.y + cellSizeInPixels.y / 2) + "px";
			divForNode.style.backgroundColor = "#ff0000";	

			returnValue.appendChild(divForNode);
		}

		return returnValue;
	}

	prototype.getNeighborsForNode = function(map, node, goalPos)
	{
		var returnValues = new Array();
		var cellPos = node.cellPos;

		var neighborPositions = new Array();

		if (cellPos.x > 0)
		{
			neighborPositions.push
			(
				new Coords(cellPos.x - 1, cellPos.y)
			);

		}
		if (cellPos.x < map.sizeInCells.x - 1)
		{
			neighborPositions.push
			(
				new Coords(cellPos.x + 1, cellPos.y)
			);
		}		
		if (cellPos.y > 0)
		{
			neighborPositions.push
			(
				new Coords(cellPos.x, cellPos.y - 1)
			);
		}
		if (cellPos.y < map.sizeInCells.y - 1)
		{
			neighborPositions.push
			(
				new Coords(cellPos.x, cellPos.y + 1)
			);
		}		

		var tempPos = new Coords(0, 0);

		for (var i = 0; i < neighborPositions.length; i++)
		{
			var neighborPos = neighborPositions[i];

			var costToTraverse = map.cellAtPos(neighborPos).terrain.costToTraverse;

			var neighborNode = new PathNode
			(
				neighborPos,
				node.costFromStart + costToTraverse,
				costToTraverse + goalPos.clone().subtract(cellPos).absolute().sumOfXAndY(),
				node
			);

			returnValues.push(neighborNode);
		}

		return returnValues;
	}
}

function PathNode(cellPos, costFromStart, costToGoalEstimated, prev)
{
	this.cellPos = cellPos;
	this.costFromStart = costFromStart;
	this.costToGoalEstimated = costToGoalEstimated;
	this.prev = prev;
}

function Terrain(name, codeChar, color, costToTraverse)
{
	this.name = name;
	this.codeChar = codeChar;
	this.color = color;
	this.costToTraverse = costToTraverse;
}

function TerrainInstances()
{}
{
	TerrainInstances.Plain = new Terrain("plain", ".", "#00aa00", 1);
	TerrainInstances.Water = new Terrain("water", "~", "#0000aa", 1000000);

	TerrainInstances._All = new Array
	(
		TerrainInstances.Plain,
		TerrainInstances.Water
	);

	TerrainInstances.BuildLookup = function()
	{
		var returnValue = new Array();

		var numberOfTerrains = TerrainInstances._All.length;

		for (var i = 0; i < numberOfTerrains; i++)
		{
			var terrain = TerrainInstances._All[i];

			returnValue[terrain.codeChar] = terrain;
		}

		return returnValue;
	}

	TerrainInstances._Lookup = TerrainInstances.BuildLookup();
}

new PathfindingTest().main();

</script>
</body>
</html>